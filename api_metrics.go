/*
 * Mux Video
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package muxvideosdk

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type MetricsApiService service

/*
MetricsApiService Get metric timeseries data
Returns timeseries data for a specific metric 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mETRICID ID of the Metric
 * @param optional nil or *GetMetricTimeseriesDataOpts - Optional Parameters:
 * @param "Timeframe" (optional.Interface of []string) -  Timeframe window to limit results by. Must be provided as an array query string parameter (e.g. timeframe[]=). Accepted formats are...   * array of epoch timestamps e.g. timeframe[]=1498867200&timeframe[]=1498953600    * duration string e.g. timeframe[]=24:hours or timeframe[]=7:days. 
 * @param "Filters" (optional.Interface of []string) -  Filter key:value pairs. Must be provided as an array query string parameter (e.g. filters[]=operating_system:windows&filters[]=country:US).  Possible filter names are the same as returned by the List Filters endpoint. 
 * @param "Measurement" (optional.String) -  Measurement for the provided metric. If omitted, the deafult for the metric will be used.
 * @param "OrderDirection" (optional.String) -  Sort order.
 * @param "GroupBy" (optional.String) -  Time granularity to group results by. If this value is omitted, a default granularity is chosen based on the supplied timeframe.
@return GetMetricTimeseriesDataResponse
*/

type GetMetricTimeseriesDataOpts struct {
	Timeframe optional.Interface
	Filters optional.Interface
	Measurement optional.String
	OrderDirection optional.String
	GroupBy optional.String
}

func (a *MetricsApiService) GetMetricTimeseriesData(ctx context.Context, mETRICID string, localVarOptionals *GetMetricTimeseriesDataOpts) (GetMetricTimeseriesDataResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetMetricTimeseriesDataResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/data/v1/metrics/{METRIC_ID}/timeseries"
	localVarPath = strings.Replace(localVarPath, "{"+"METRIC_ID"+"}", fmt.Sprintf("%v", mETRICID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeframe.IsSet() {
		localVarQueryParams.Add("timeframe[]", parameterToString(localVarOptionals.Timeframe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Filters.IsSet() {
		localVarQueryParams.Add("filters[]", parameterToString(localVarOptionals.Filters.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Measurement.IsSet() {
		localVarQueryParams.Add("measurement", parameterToString(localVarOptionals.Measurement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderDirection.IsSet() {
		localVarQueryParams.Add("order_direction", parameterToString(localVarOptionals.OrderDirection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupBy.IsSet() {
		localVarQueryParams.Add("group_by", parameterToString(localVarOptionals.GroupBy.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetMetricTimeseriesDataResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MetricsApiService Get Overall values
Returns the overall value for a specific metric, as well as the total view count, watch time, and the Mux Global metric value for the metric. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mETRICID ID of the Metric
 * @param optional nil or *GetOverallValuesOpts - Optional Parameters:
 * @param "Timeframe" (optional.Interface of []string) -  Timeframe window to limit results by. Must be provided as an array query string parameter (e.g. timeframe[]=). Accepted formats are...   * array of epoch timestamps e.g. timeframe[]=1498867200&timeframe[]=1498953600    * duration string e.g. timeframe[]=24:hours or timeframe[]=7:days. 
 * @param "Filters" (optional.Interface of []string) -  Filter key:value pairs. Must be provided as an array query string parameter (e.g. filters[]=operating_system:windows&filters[]=country:US).  Possible filter names are the same as returned by the List Filters endpoint. 
 * @param "Measurement" (optional.String) -  Measurement for the provided metric. If omitted, the deafult for the metric will be used.
@return GetOverallValuesResponse
*/

type GetOverallValuesOpts struct {
	Timeframe optional.Interface
	Filters optional.Interface
	Measurement optional.String
}

func (a *MetricsApiService) GetOverallValues(ctx context.Context, mETRICID string, localVarOptionals *GetOverallValuesOpts) (GetOverallValuesResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetOverallValuesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/data/v1/metrics/{METRIC_ID}/overall"
	localVarPath = strings.Replace(localVarPath, "{"+"METRIC_ID"+"}", fmt.Sprintf("%v", mETRICID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeframe.IsSet() {
		localVarQueryParams.Add("timeframe[]", parameterToString(localVarOptionals.Timeframe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Filters.IsSet() {
		localVarQueryParams.Add("filters[]", parameterToString(localVarOptionals.Filters.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Measurement.IsSet() {
		localVarQueryParams.Add("measurement", parameterToString(localVarOptionals.Measurement.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GetOverallValuesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MetricsApiService List all metric values
List all of the values across every breakdown for a specific metric 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ListAllMetricValuesOpts - Optional Parameters:
 * @param "Timeframe" (optional.Interface of []string) -  Timeframe window to limit results by. Must be provided as an array query string parameter (e.g. timeframe[]=). Accepted formats are...   * array of epoch timestamps e.g. timeframe[]=1498867200&timeframe[]=1498953600    * duration string e.g. timeframe[]=24:hours or timeframe[]=7:days. 
 * @param "Filters" (optional.Interface of []string) -  Filter key:value pairs. Must be provided as an array query string parameter (e.g. filters[]=operating_system:windows&filters[]=country:US).  Possible filter names are the same as returned by the List Filters endpoint. 
 * @param "Dimension" (optional.String) -  Dimension the specified value belongs to
 * @param "Value" (optional.String) -  Value to show all available metrics for
@return ListAllMetricValuesResponse
*/

type ListAllMetricValuesOpts struct {
	Timeframe optional.Interface
	Filters optional.Interface
	Dimension optional.String
	Value optional.String
}

func (a *MetricsApiService) ListAllMetricValues(ctx context.Context, localVarOptionals *ListAllMetricValuesOpts) (ListAllMetricValuesResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListAllMetricValuesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/data/v1/metrics/comparison"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeframe.IsSet() {
		localVarQueryParams.Add("timeframe[]", parameterToString(localVarOptionals.Timeframe.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Filters.IsSet() {
		localVarQueryParams.Add("filters[]", parameterToString(localVarOptionals.Filters.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Dimension.IsSet() {
		localVarQueryParams.Add("dimension", parameterToString(localVarOptionals.Dimension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarQueryParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ListAllMetricValuesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MetricsApiService List breakdown values
List the breakdown values for a specific metric 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mETRICID ID of the Metric
 * @param optional nil or *ListBreakdownValuesOpts - Optional Parameters:
 * @param "GroupBy" (optional.String) -  Breakdown value to group the results by
 * @param "Measurement" (optional.String) -  Measurement for the provided metric. If omitted, the deafult for the metric will be used.
 * @param "Filters" (optional.Interface of []string) -  Filter key:value pairs. Must be provided as an array query string parameter (e.g. filters[]=operating_system:windows&filters[]=country:US).  Possible filter names are the same as returned by the List Filters endpoint. 
 * @param "Limit" (optional.Int32) -  Number of items to include in the response
 * @param "Page" (optional.Int32) -  Offset by this many pages, of the size of `limit`
 * @param "OrderBy" (optional.String) -  Value to order the results by
 * @param "OrderDirection" (optional.String) -  Sort order.
 * @param "Timeframe" (optional.Interface of []string) -  Timeframe window to limit results by. Must be provided as an array query string parameter (e.g. timeframe[]=). Accepted formats are...   * array of epoch timestamps e.g. timeframe[]=1498867200&timeframe[]=1498953600    * duration string e.g. timeframe[]=24:hours or timeframe[]=7:days. 
@return ListBreakdownValuesResponse
*/

type ListBreakdownValuesOpts struct {
	GroupBy optional.String
	Measurement optional.String
	Filters optional.Interface
	Limit optional.Int32
	Page optional.Int32
	OrderBy optional.String
	OrderDirection optional.String
	Timeframe optional.Interface
}

func (a *MetricsApiService) ListBreakdownValues(ctx context.Context, mETRICID string, localVarOptionals *ListBreakdownValuesOpts) (ListBreakdownValuesResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListBreakdownValuesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/data/v1/metrics/{METRIC_ID}/breakdown"
	localVarPath = strings.Replace(localVarPath, "{"+"METRIC_ID"+"}", fmt.Sprintf("%v", mETRICID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.GroupBy.IsSet() {
		localVarQueryParams.Add("group_by", parameterToString(localVarOptionals.GroupBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Measurement.IsSet() {
		localVarQueryParams.Add("measurement", parameterToString(localVarOptionals.Measurement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filters.IsSet() {
		localVarQueryParams.Add("filters[]", parameterToString(localVarOptionals.Filters.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderDirection.IsSet() {
		localVarQueryParams.Add("order_direction", parameterToString(localVarOptionals.OrderDirection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeframe.IsSet() {
		localVarQueryParams.Add("timeframe[]", parameterToString(localVarOptionals.Timeframe.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ListBreakdownValuesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MetricsApiService List Insights
Returns a list of insights for a metric. These are the worst performing values across all breakdowns sorted by how much they negatively impact a specific metric. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mETRICID ID of the Metric
 * @param optional nil or *ListInsightsOpts - Optional Parameters:
 * @param "Measurement" (optional.String) -  Measurement for the provided metric. If omitted, the deafult for the metric will be used.
 * @param "OrderDirection" (optional.String) -  Sort order.
 * @param "Timeframe" (optional.Interface of []string) -  Timeframe window to limit results by. Must be provided as an array query string parameter (e.g. timeframe[]=). Accepted formats are...   * array of epoch timestamps e.g. timeframe[]=1498867200&timeframe[]=1498953600    * duration string e.g. timeframe[]=24:hours or timeframe[]=7:days. 
@return ListInsightsResponse
*/

type ListInsightsOpts struct {
	Measurement optional.String
	OrderDirection optional.String
	Timeframe optional.Interface
}

func (a *MetricsApiService) ListInsights(ctx context.Context, mETRICID string, localVarOptionals *ListInsightsOpts) (ListInsightsResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListInsightsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/data/v1/metrics/{METRIC_ID}/insights"
	localVarPath = strings.Replace(localVarPath, "{"+"METRIC_ID"+"}", fmt.Sprintf("%v", mETRICID), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Measurement.IsSet() {
		localVarQueryParams.Add("measurement", parameterToString(localVarOptionals.Measurement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderDirection.IsSet() {
		localVarQueryParams.Add("order_direction", parameterToString(localVarOptionals.OrderDirection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeframe.IsSet() {
		localVarQueryParams.Add("timeframe[]", parameterToString(localVarOptionals.Timeframe.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ListInsightsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
